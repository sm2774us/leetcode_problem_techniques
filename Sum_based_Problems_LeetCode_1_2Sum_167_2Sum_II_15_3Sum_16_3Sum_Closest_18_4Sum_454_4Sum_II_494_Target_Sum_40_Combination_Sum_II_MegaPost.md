# Solution Explanation of popular Sum-Based Problems on LeetCode

| Questions | Solution | Difficulty | Pattern | Companies |
| --------- | -------- | ---------- | ------- | --------- |
| [LeetCode - Problem 1 - Two Sum](https://leetcode.com/problems/two-sum/) | [Solution](./Two_Pointers_Approach/001_LeetCode_P_0001_Two_Sum_Solution.py) | ![Easy_Icon](assets/difficulty/easy_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![hash_table](assets/pattern/hash_table.PNG)![two_pointers](assets/pattern/two_pointers.PNG) | ![Two_Sum_Companies_Asked](assets/companies/leetcode_p_0001_two_sum_companies_asked.PNG) |
| [LeetCode - Problem 167 - Two Sum II](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/) | [Solution](./Two_Pointers_Approach/003_LeetCode_P_0167_Two_Sum_Part_2_Input_Array_is_Sorted_Solution.py) | ![Easy_Icon](assets/difficulty/easy_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![two_pointers](assets/pattern/two_pointers.PNG)![binary_search](assets/pattern/binary_search.PNG) | ![Two_Sum_II_Companies_Asked](assets/companies/leetcode_p_0001_two_sum_companies_asked.PNG) |
| [LeetCode - Problem 15 - 3Sum](https://leetcode.com/problems/3sum/) | [Solution](./Two_Pointers_Approach/008_LeetCode_P_0015_Three_Sum_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![two_pointers](assets/pattern/two_pointers.PNG) | ![3Sum_Companies_Asked](assets/companies/air_bnb.PNG)![3Sum_Companies_Asked](assets/companies/amazon.PNG)![3Sum_Companies_Asked](assets/companies/facebook.PNG)![3Sum_Companies_Asked](assets/companies/linked_in.PNG)![3Sum_Companies_Asked](assets/companies/microsoft.PNG)![3Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 16 - 3Sum Closest](https://leetcode.com/problems/3sum-closest/) | [Solution](./Two_Pointers_Approach/009_LeetCode_P_0016_Three_Sum_Closest_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![two_pointers](assets/pattern/two_pointers.PNG) | ![3Sum_Companies_Asked](assets/companies/air_bnb.PNG)![3Sum_Companies_Asked](assets/companies/amazon.PNG)![3Sum_Companies_Asked](assets/companies/facebook.PNG)![3Sum_Companies_Asked](assets/companies/linked_in.PNG)![3Sum_Companies_Asked](assets/companies/microsoft.PNG)![3Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 259 - 3Sum Smaller](https://leetcode.com/problems/3sum-smaller/) | [Solution](./Two_Pointers_Approach/010_LeetCode_P_0259_Three_Sum_Smaller_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![two_pointers](assets/pattern/two_pointers.PNG) | ![3Sum_Companies_Asked](assets/companies/air_bnb.PNG)![3Sum_Companies_Asked](assets/companies/amazon.PNG)![3Sum_Companies_Asked](assets/companies/facebook.PNG)![3Sum_Companies_Asked](assets/companies/linked_in.PNG)![3Sum_Companies_Asked](assets/companies/microsoft.PNG)![3Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 923 - 3Sum With Multiplicity](https://leetcode.com/problems/3sum-with-multiplicity/) | [Solution](./Two_Pointers_Approach/011_LeetCode_P_0923_Three_Sum_With_Multiplicity_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![two_pointers](assets/pattern/two_pointers.PNG) | ![3Sum_Companies_Asked](assets/companies/air_bnb.PNG)![3Sum_Companies_Asked](assets/companies/amazon.PNG)![3Sum_Companies_Asked](assets/companies/facebook.PNG)![3Sum_Companies_Asked](assets/companies/linked_in.PNG)![3Sum_Companies_Asked](assets/companies/microsoft.PNG)![3Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 18 - 4Sum](https://leetcode.com/problems/4sum/) | [Solution](Two_Pointers_Approach/012_LeetCode_P_0018_Four_Sum_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![hash_table](assets/pattern/hash_table.PNG)![two_pointers](assets/pattern/two_pointers.PNG) | ![4Sum_Companies_Asked](assets/companies/air_bnb.PNG)![4Sum_Companies_Asked](assets/companies/amazon.PNG)![4Sum_Companies_Asked](assets/companies/facebook.PNG)![4Sum_Companies_Asked](assets/companies/linked_in.PNG)![4Sum_Companies_Asked](assets/companies/microsoft.PNG)![4Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 454 - 4Sum II](https://leetcode.com/problems/4sum-ii/) | [Solution](Two_Pointers_Approach/013_LeetCode_P_0454_Four_Sum_Part_2_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![hash_table](assets/pattern/hash_table.PNG)![binary_search](assets/pattern/binary_search.PNG) | ![4Sum_Companies_Asked](assets/companies/air_bnb.PNG)![4Sum_Companies_Asked](assets/companies/amazon.PNG)![4Sum_Companies_Asked](assets/companies/facebook.PNG)![4Sum_Companies_Asked](assets/companies/linked_in.PNG)![4Sum_Companies_Asked](assets/companies/microsoft.PNG)![4Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 40 - Combination Sum II](https://leetcode.com/problems/combination-sum-ii/) | [Solution](Backtracking_Approach/001_LeetCode_P_0040_Combination_Sum_Part_2_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![hash_table](assets/pattern/hash_table.PNG)![binary_search](assets/pattern/binary_search.PNG) | ![4Sum_Companies_Asked](assets/companies/air_bnb.PNG)![4Sum_Companies_Asked](assets/companies/amazon.PNG)![4Sum_Companies_Asked](assets/companies/facebook.PNG)![4Sum_Companies_Asked](assets/companies/linked_in.PNG)![4Sum_Companies_Asked](assets/companies/microsoft.PNG)![4Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 494 - Target Sum](https://leetcode.com/problems/target-sum/) | [Solution](Dynamic_Programming_Approach/001_LeetCode_P_0494_Target_Sum_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![dynamic_programming](assets/pattern/dynamic_programming.PNG)![DFS](assets/pattern/DFS.PNG) | ![4Sum_Companies_Asked](assets/companies/air_bnb.PNG)![4Sum_Companies_Asked](assets/companies/amazon.PNG)![4Sum_Companies_Asked](assets/companies/facebook.PNG)![4Sum_Companies_Asked](assets/companies/linked_in.PNG)![4Sum_Companies_Asked](assets/companies/microsoft.PNG)![4Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 373 - Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/) | [Solution](Two_Pointers_Approach/013_LeetCode_P_0454_Four_Sum_Part_2_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![hash_table](assets/pattern/hash_table.PNG)![binary_search](assets/pattern/binary_search.PNG) | ![4Sum_Companies_Asked](assets/companies/air_bnb.PNG)![4Sum_Companies_Asked](assets/companies/amazon.PNG)![4Sum_Companies_Asked](assets/companies/facebook.PNG)![4Sum_Companies_Asked](assets/companies/linked_in.PNG)![4Sum_Companies_Asked](assets/companies/microsoft.PNG)![4Sum_Companies_Asked](assets/companies/oracle.PNG) |
| [LeetCode - Problem 611 - Valid Triangle Number](https://leetcode.com/problems/valid-triangle-number/) | [Solution](Two_Pointers_Approach/013_LeetCode_P_0454_Four_Sum_Part_2_Solution.py) | ![Medium_Icon](assets/difficulty/medium_problem_type_icon.PNG) | ![array](assets/pattern/array.PNG)![hash_table](assets/pattern/hash_table.PNG)![binary_search](assets/pattern/binary_search.PNG) | ![4Sum_Companies_Asked](assets/companies/air_bnb.PNG)![4Sum_Companies_Asked](assets/companies/amazon.PNG)![4Sum_Companies_Asked](assets/companies/facebook.PNG)![4Sum_Companies_Asked](assets/companies/linked_in.PNG)![4Sum_Companies_Asked](assets/companies/microsoft.PNG)![4Sum_Companies_Asked](assets/companies/oracle.PNG) |

If you're a newbie and sometimes have a hard time understanding the logic. 
Don't worry, you'll catch up after a month of doing Leetcode on a daily basis. 
Try to do it, even one example per day. It'd help. 
I've compiled a bunch on `sum` problems here, go ahead and check it out. 
Also, I think focusing on a subject and doing 3-4 problems would help to get the idea behind solution 
since they mostly follow the same logic. Of course there are other ways to solve each problems, 
but I try to be as uniform as possible. 
Good luck.

In general, `sum` problems can be categorized into two categories: 
1. There is any array and you add some numbers to get to (or close to) a `target`, or, 
1. You need to return indices of numbers that sum up to a (or close to) a `target` value. 

Note that when the problem is looking for indices, `sort`ing the array is probably NOT a good idea.

**[Two Sum:](https://leetcode.com/problems/two-sum/)**

This is the second type of the problems where we're looking for indices, so sorting is not necessary. 
What you'd want to do is to go over the array, and try to find two integers that sum up to a `target` value. 
Most of the times, in such a problem, using dictionary (hashtable) helps. 
You try to keep track of you've observations in a dictionary and use it once you get to the results.

Note: Try to be comfortable to use `enumerate` as it's sometime out of comfort zone for newbies. 
`enumerate` comes handy in a lot of problems (I mean if you want to have cleaner code of course). 
If I had to choose three built-in functions/methods that I wasn't comfortable with at the start 
and have found them super helpful, I'd probably say `enumerate`, `zip` and `set`.

Solution: In this problem, you initialize a dictionary (`seen`). 
This dictionary will keep track of numbers (as `key`) and indices (as `value`). 
So, you go over your array (line `#1`) using `enumerate` that gives you both index and value of elements in an array. 
As an example, let's do `nums = [2,3,1]` and `target = 3`. Let's say you're at index `i = 0` and `value = 2`, ok? 
You need to find `value = 1` to finish the problem, meaning, `target - 2 = 1`. 1 here is the `remaining`. 
Since `remaining + value = target`, you're done once you found it, right? 
So when going through the array, you calculate the `remaining` and check to see whether `remaining` 
is in the `seen` dictionary (line `#3`). If it is, you're done! You're remaining from `seen` and the current number  
would give you the output (line `#4`). Otherwise, you add your current number to the dictionary (line `#5`) 
since it's going to be a `remaining` for (probably) a number you'll see in the future assuming that 
there is at least one instance of answer.

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        if not nums or len(nums) < 2:
            return []
        seen = {}
        for i, value in enumerate(nums): #1
            remaining = target - nums[i] #2
           
            if remaining in seen: #3
                #return [i, seen[remaining]]  #4 => This is allowable as well and is a valid solution
                return [seen[remaining], i]  #4
            else:
                seen[value] = i  #5
```

**Complexity Analysis:**
* **Time complexity :** `O(N)`.
  
    We traverse the list containing n elements once. Each look up in a hash table costs O(1) time.
    So `n` insertions and `n` lookups in a hash table takes expected time of `O(N)`.
  
* **Space complexity :** `O(N)`.
  
    The extra space required depends on the number of items stored in the dictionary, which stores at most n elements.

**Complexity Analysis for all possible Solutions:**

| **Approach** | **Time Complexity** | **Space Complexity** |
| ------------ | ------------------- | -------------------- |
| Brute Force | `O(N^2)` | `O(1)` |
| Binary Search | `O(N*log(N))`<br><br>`O(N*log(N))` for sort + `O(N)` for lookup = `O(N*log(N))` | `O(N)`<br>for storing sorted array and  indexes of the numbers in initial array |
| Two Pointers | `O(N*log(N))`<br><br>`O(N*log(N))` for sort + `O(N)` for lookup = `O(N*log(N))` | `O(N)`<br>for storing sorted array and  indexes of the numbers in initial array |
| **Using hashtable** | `O(N)` | `O(N)` |


**[Two Sum II:](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)**

For this, you can do exactly as the previous. 
The only change I made below was to change the order of line `#4`. 
In the previous example, the order didn't matter. 
But, here the problem asks for ascending order and since the values/indices in `seen` 
has always lower indices than your current number, it should come first. 
Also, note that the problem says it's not zero based, meaning that indices don't start from zero, 
that's why I added 1 to both of them.

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        if not nums or len(nums) < 2:
            return []
        seen = {}
        for i, value in enumerate(nums): 
            remaining = target - nums[i] 
           
            if remaining in seen: 
                return [seen[remaining]+1, i+1]  #4
            else:
                seen[value] = i
```

Another approach to solve this problem (probably what Leetcode is looking for) is to treat it as 
first category of problems. Since the array is already sorted, this works. You see the following approach 
in a lot of problems. What you want to do is to have two pointer (if it was 3sum, you'd need three pointers 
as you'll see in the future examples). One pointer move from left and one from right. 
Let's say your `nums = [1,3,6,9]` and your `target = 10`. Now, `left` points to 1 at first, 
and `right` points to 9. 

There are three possibilities => If you sum numbers that `left` and `right` are pointing at, you get `temp_sum` (line `#1`). 
1. If `temp_sum` is your `target`, you'r done! You return it (line `#9`).
1. If the `temp_sum` is more than your `target`, it means that `right` is pointing to a very large value (line `#5`) 
   and you need to bring it a little bit to the left to a smaller (`right` maybe equal) value (line `#6`) 
   by adding one to the index.
1. If the `temp_sum` is less than your `target` (line `#7`), then you need to move your left to a little 
   bit larger value by adding one to the index (line `#9`).

This way, you try to narrow down the range in which you're looking at and will eventually find a couple of numbers 
that sum to `target`, then, you'll return this in line `#9`. 
In this problem, since it says there is only one solution, nothing extra is necessary. 
However, when a problem asks to return all combinations that sum to `target`, you can't simply 
return the first instance and you need to collect all the possibilities and return the list altogether 
(you'll see something like this in the next example).

```python
from typing import List

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        if not nums or len(nums) < 2:
            return []
     
        for left in range(len(nums)-1): #1
            right = len(nums) - 1 #2
            while left < right: #3
                temp_sum = nums[left] + nums[right] #4
                if temp_sum > target:  #5
                    right -= 1 #6
                elif temp_sum < target: #7
                    left +=1 #8
                else:
                    return [left+1, right+1] #9
```

**Complexity Analysis:**
* **Time complexity :** `O(N)`.
  
    We traverse the list containing n elements once.

* **Space complexity :** `O(1)`.
  
    Constant space. The solution uses only `O(1)` space since no auxiliary structures are created.

**Complexity Analysis for all possible Solutions:**

| **Approach** | **Time Complexity** | **Space Complexity** |
| ------------ | ------------------- | -------------------- |
| Brute Force | `O(N^2)` | `O(1)` |
| Binary Search | `O(N*log(N))`<br><br>`O(N*log(N))` for sort + `O(N)` for lookup = `O(N*log(N))` | `O(1)` |
| Using hashtable | `O(N)` | `O(N)` |
| **Two Pointers** | `O(N)` | `O(1)` |

Why does **Two Pointers Approach** beat the **Hash Table Approach** ?
* The time of computing hash value is longer than the time of computing the sum of two numbers.
* And, besides, the iteration of the two pointer solution is from left and right, which is faster 
  than the hash table Solution, whose iteration is from a single edge.


**[3Sum:](https://leetcode.com/problems/3sum/)**

This is similar to the previous example except that it's looking for three numbers. 
There are some minor differences in the problem statement: 
* It's looking for all combinations (not just one) of solutions returned as a list. 
* And second, it's looking for unique combination, repetition is not allowed.

Here, instead of looping (line `#1`) to `len(nums)-1`, we loop to `len(nums)-2` since we're looking for three numbers. 
Since we're returning values, `sort` would be a good idea. Otherwise, if the `nums` is not sorted, 
you cannot reduce `right` pointer or increase `left` pointer easily, makes sense?

So, first you `sort` the array and define `res = []` to collect your outputs. 
In line `#2`, we check whether two consecutive elements are equal or not because if they are, 
we don't want them (solutions need to be unique) and will skip to the next set of numbers. 
Also, there is an additional constraint in this line that `i > 0`. 
This is added to take care of cases like `nums = [1,1,1]` and `target = 3`. 
If we didn't have `i > 0`, then we'd skip the only correct solution and would return `[]` 
as our answer which is wrong (correct answer is `[[1,1,1]]`).

We define two additional pointers this time, `left = i + 1` and `right = len(nums) - 1`. 
For example, if `nums = [-2,-1,0,1,2]`, all the pointers in the case of `i=1` are looking at: 
`i` at `-1`, `left` at `0` and `right` at `2`. We then check `temp` variable similar to the previous example. 
There is only one change with respect to the previous example here between lines `#5` and `#10`. 
If we have the `temp = target`, we obviously add this set to the `res` in line `#5`, right? 
However, we're not done yet. 
For a fixed `i`, we still need to check and see whether 
there are other combinations by just changing `left` and `right` pointers. 
That's what we are doing in lines `#6, 7, 8`. 

1. If we still have the condition of `left < right` and `nums[left]` and the number to the right of it 
   are not the same, we move `left` one index to right (line `#6`). 
1. Similarly, if `nums[right]` and the number to left of it are not the same, we move 
   `right` one index to left. 

This way for a fixed `i`, we get rid of repetitive cases. For example, if `nums = [-3, 1, 1, 3, 5]` and `target = 3`, 
one we get the first `[-3,1,5]`, `left = 1`, but, `nums[2]` is also 1 which we don't want the `left` variable 
to look at it simply because it'd again return `[-3,1,5]`, right? 
So, we move `left` one index. Finally, if the repeating elements don't exist, lines `#6` to `#8` won't get activated. 
In this case we still need to move forward by adding `1` to `left` and extracting 1 from `right` (lines `#9, 10`).

```python
from typing import List

class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        if not nums or len(nums) < 3:
            return []
        if len(nums) == 3:
            return [nums] if sum(nums) == 0 else []
        
        nums.sort()
        res = []

        for i in range(len(nums)-2): #1
            if i > 0 and nums[i] == nums[i-1]: #2
                continue
            left = i + 1 #3
            right = len(nums) - 1 #4
            
            while left < right:  
                temp = nums[i] + nums[left] + nums[right]
                                    
                if temp > 0:
                    right -= 1
                    
                elif temp < 0:
                    left += 1
                
                else:
                    res.append([nums[i], nums[left], nums[right]]) #5
                    while left < right and nums[left] == nums[left + 1]: #6
                        left += 1
                    while left < right and nums[right] == nums[right-1]:#7
                        right -= 1    #8
                
                    right -= 1 #9 
                    left += 1 #10
```

Another way to solve this problem is to change it into a two sum problem. 
Instead of finding `a+b+c = 0`, you can find `a+b = -c` where we want to 
find two numbers `a` and `b` that are equal to `-c`, right? 
This is similar to the first problem. Remember if you wanted to use the exact same as the first code, 
it'd return indices and not numbers. 
Also, we need to re-arrange this problem in a way that we have `nums` and `target`.

```python
from typing import List
from typing import Set

class Solution:

    def two_sum(self, idx: int, nums: List[int]) -> Set[int]:
        target = -nums[idx]
        left, right = 0, len(nums) - 1
        two_sum_set = set()
        while left < right:
            if left == idx or right == idx:
                if left == idx:
                    left += 1
                else:
                    right -= 1
                continue
            if nums[left] + nums[right] > target:
                right -= 1
            elif nums[left] + nums[right] < target:
                left += 1
            else:
                two_sum_set.add((nums[left], nums[right]))
                left += 1
                right -= 1
        return two_sum_set

    def threeSum(self, nums: List[int]) -> List[List[int]]:
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        if not nums or len(nums) < 3:
            return []
        if len(nums) == 3:
            return [nums] if sum(nums) == 0 else []
        nums.sort()  # help to avoid duplicate triplets
        three_sum_set = set()  # using set to hold unique triplets
        for i in range(len(nums)):
            if i > 0 and nums[i] == nums[i - 1]:  # no need to check this case becasue results would be duplicates
                continue
            two_set_sum = self.two_sum(i, nums)
            for num1, num2 in two_set_sum:
                candidates = [nums[i], num1, num2]
                candidates.sort()
                three_sum_set.add((candidates[0], candidates[1], candidates[2]))
        return [[num1, num2, num3] for num1, num2, num3 in three_sum_set]
```

**Complexity Analysis:**
Every higher SUM will have `O(N)` multiplied to the complexity of 2SUM.

* **Time complexity :** `O(N^2)` [ Quadratic Time Complexity ].
  3Sum = O(N)

* **Space complexity :** `O(N)`.

**[3sum Closest](https://leetcode.com/problems/3sum-closest/)

This is similar to the traditional 3sum problem except that you are trying to
determine the sum of three numbers that are closest to the `target`.

```python
from typing import List
from math import inf

import unittest

class Solution:
    # Solution : Two-Pointers Technique
    #
    # TC: O(N^2)
    # SC: O(1)
    #
    # Follow-up Question: Can we do better than O(N^2) ?
    # -------------------
    # Answer            : No there isn't. Proof by contradiction:
    # -------------------
    #                     If we had sub-quadratic solution to this problem then we could solve all instances
    #                     of 3SUM problem with the same complexity (sub-quadratic),
    #                     but lower bound of 3SUM problem is O(N^2).
    #
    # NOTE:
    # -------------------
    # You can get some improvement by skipping the duplicate value while i++,
    # it certainly saves time as you don't need to enter the sub-iteration each time.
    def threeSumClosest(self, nums: List[int], target: int) -> int:
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if not nums or len(nums) < 3: return
        
        nums.sort()
        result = nums[0] + nums[1] + nums[2]
        for i in range(len(nums) - 2):

            # update: ignore the duplicate numbers
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            left, right = i + 1, len(nums) - 1
            while left < right:
                currentSum = nums[left] + nums[right] + nums[i]
                if currentSum == target:
                    return target
                if abs(currentSum - target) < abs(result - target):
                    result = currentSum
                if currentSum < target:
                    left += 1
                else:
                    right -= 1
        return result
```

Another way to solve this problem is to change it into a two sum problem, as shown below:

```python
from typing import List
from math import inf

import unittest

class Solution:
    def twoSumClosest(self, nums: List[int], target: int) -> int:
        # assume nums is sorted
        n = len(nums)
        i, j = 0, n - 1
        res = inf
        while i < j:
            dis = nums[i] + nums[j] - target
            if abs(dis) < abs(res): res = dis

            if nums[i] + nums[j] == target: return target
            if nums[i] + nums[j] < target:
                i += 1
            else:
                j -= 1
        return res + target

    # Solution : Two-Pointers Technique
    #
    # TC: O(N^2)
    # SC: O(1)
    #
    # Follow-up Question: Can we do better than O(N^2) ?
    # -------------------
    # Answer            : No there isn't. Proof by contradiction:
    # -------------------
    #                     If we had sub-quadratic solution to this problem then we could solve all instances
    #                     of 3SUM problem with the same complexity (sub-quadratic),
    #                     but lower bound of 3SUM problem is O(N^2).
    #
    # NOTE:
    # -------------------
    # You can get some improvement by skipping the duplicate value while i++,
    # it certainly saves time as you don't need to enter the sub-iteration each time.
    def threeSumClosest_decomposed_as_two_sum(self, nums: List[int], target: int) -> int:
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        if not nums or len(nums) < 3: return
        
        nums.sort()
        n = len(nums)
        res = inf
        for i in range(n - 2):

            # update: ignore the duplicate numbers
            if i > 0 and nums[i] == nums[i - 1]:
                continue

            if nums[i] + nums[i + 1] + nums[i + 2] > target:
                rec = nums[i] + nums[i + 1] + nums[i + 2] - target
            elif nums[i] + nums[n - 2] + nums[n - 1] < target:
                rec = nums[i] + nums[n - 2] + nums[n - 1] - target
            else:
                rec = nums[i] + self.twoSumClosest(nums[i + 1:], target - nums[i]) - target
            if abs(rec) < abs(res): res = rec

        return res + target

```

**[3Sum Smaller:](https://leetcode.com/problems/3sum-smaller/)**

**[3Sum With Multiplicity:](https://leetcode.com/problems/3sum-with-multiplicity/)**

**[4sum:](https://leetcode.com/problems/4sum/)**

**[4Sum II:](https://leetcode.com/problems/4sum-ii/)**

**[k-Sum:](https://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem)**

`k`-SUM can be solved more quickly as follows :

* **For even `k`:** Compute a sorted list `S` of all sums of `k/2` input elements. 
  Check whether `S` contains both some number `x` and its negation `−x`. 
  The algorithm runs in ![equation](http://latex.codecogs.com/svg.latex?O(n%5E%7Bk/2%7D*log(n))) time.
* **For odd `k`:** Compute the sorted list `S` of all sums of `(k−1)/2` input elements. 
  For each input element `a`, check whether `S` contains both `x` and `−a−x`, 
  for some number `x`. (The second step is essentially the 
  ![equation](http://latex.codecogs.com/svg.latex?O(n%5E2)%20)-time algorithm for 3SUM.). 
  The algorithm runs in ![equation](http://latex.codecogs.com/svg.latex?O(n%5E%7B(k&plus;1)/2%7D)%20) time.

Both algorithms are optimal (except possibly for the log factor when `k` is even and bigger than `2`) 
for any constant `k` in a certain weak but natural restriction of the linear decision tree model of computation. 
For more details, see:

* Nir Ailon and Bernard Chazelle. [Lower bounds for linear degeneracy testing](http://www.cs.princeton.edu/~chazelle/pubs/lindegen-jacm.pdf). JACM 2005.
* Jeff Erickson. [Lower bounds for linear satisfiability problems](http://compgeom.cs.uiuc.edu/~jeffe/pubs/linsat.html). CJTCS 1999.

**Source:** https://cs.stackexchange.com/questions/2973/generalised-3sum-k-sum-problem

**[Combination Sum II:](https://leetcode.com/problems/combination-sum-ii/)**
**[Target Sum:](https://leetcode.com/problems/target-sum/)**
